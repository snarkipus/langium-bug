"use strict";
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultCompletionProvider = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const ast = __importStar(require("../../grammar/generated/ast"));
const internal_grammar_util_1 = require("../../grammar/internal-grammar-util");
const ast_util_1 = require("../../utils/ast-util");
const cst_util_1 = require("../../utils/cst-util");
const grammar_util_1 = require("../../utils/grammar-util");
const stream_1 = require("../../utils/stream");
const follow_element_computation_1 = require("./follow-element-computation");
class DefaultCompletionProvider {
    constructor(services) {
        this.scopeProvider = services.references.ScopeProvider;
        this.grammar = services.Grammar;
        this.completionParser = services.parser.CompletionParser;
        this.nameProvider = services.references.NameProvider;
        this.grammarConfig = services.parser.GrammarConfig;
    }
    async getCompletion(document, params) {
        const root = document.parseResult.value;
        const cst = root.$cstNode;
        if (!cst) {
            return undefined;
        }
        const items = [];
        const textDocument = document.textDocument;
        const text = textDocument.getText();
        const offset = textDocument.offsetAt(params.position);
        const acceptor = value => {
            const completionItem = this.fillCompletionItem(textDocument, offset, value);
            if (completionItem) {
                items.push(completionItem);
            }
        };
        const node = (0, cst_util_1.findLeafNodeAtOffset)(cst, this.backtrackToAnyToken(text, offset));
        const context = {
            document,
            textDocument,
            node: node === null || node === void 0 ? void 0 : node.element,
            offset,
            position: params.position
        };
        if (!node) {
            const parserRule = (0, grammar_util_1.getEntryRule)(this.grammar);
            await this.completionForRule(context, parserRule, acceptor);
            return vscode_languageserver_1.CompletionList.create(items, true);
        }
        const parserStart = this.backtrackToTokenStart(text, offset);
        const beforeFeatures = this.findFeaturesAt(textDocument, parserStart);
        let afterFeatures = [];
        const reparse = this.canReparse() && offset !== parserStart;
        if (reparse) {
            afterFeatures = this.findFeaturesAt(textDocument, offset);
        }
        const distinctionFunction = (element) => {
            if (ast.isKeyword(element.feature)) {
                return element.feature.value;
            }
            else {
                return element.feature;
            }
        };
        await Promise.all((0, stream_1.stream)(beforeFeatures)
            .distinct(distinctionFunction)
            .map(e => this.completionFor(context, e, acceptor)));
        if (reparse) {
            await Promise.all((0, stream_1.stream)(afterFeatures)
                .exclude(beforeFeatures, distinctionFunction)
                .distinct(distinctionFunction)
                .map(e => this.completionFor(context, e, acceptor)));
        }
        return vscode_languageserver_1.CompletionList.create(items, true);
    }
    /**
     * Determines whether the completion parser will reparse the input at the point of completion.
     * By default, this returns `false`, indicating that the completion will only look for completion results starting from the token at the cursor position.
     * Override this and return `true` to indicate that the completion should parse the input a second time.
     * This might add some missing completions at the cost at parsing the input twice.
     */
    canReparse() {
        return false;
    }
    findFeaturesAt(document, offset) {
        const text = document.getText({
            start: vscode_languageserver_1.Position.create(0, 0),
            end: document.positionAt(offset)
        });
        const parserResult = this.completionParser.parse(text);
        const tokens = parserResult.tokens;
        // If the parser didn't parse any tokens, return the next features of the entry rule
        if (parserResult.tokenIndex === 0) {
            const parserRule = (0, grammar_util_1.getEntryRule)(this.grammar);
            const firstFeatures = (0, follow_element_computation_1.findFirstFeatures)({
                feature: parserRule.definition,
                new: true,
                type: (0, internal_grammar_util_1.getExplicitRuleType)(parserRule)
            });
            if (tokens.length > 0) {
                // We have to skip the first token
                // The interpreter will only look at the next features, which requires every token after the first
                tokens.shift();
                return (0, follow_element_computation_1.findNextFeatures)(firstFeatures.map(e => [e]), tokens);
            }
            else {
                return firstFeatures;
            }
        }
        const leftoverTokens = [...tokens].splice(parserResult.tokenIndex);
        const features = (0, follow_element_computation_1.findNextFeatures)([parserResult.elementStack.map(feature => ({ feature }))], leftoverTokens);
        return features;
    }
    backtrackToAnyToken(text, offset) {
        if (offset >= text.length) {
            offset = text.length - 1;
        }
        while (offset > 0 && /\s/.test(text.charAt(offset))) {
            offset--;
        }
        return offset;
    }
    backtrackToTokenStart(text, offset) {
        if (offset < 1) {
            return offset;
        }
        const wordRegex = this.grammarConfig.nameRegexp;
        let lastCharacter = text.charAt(offset - 1);
        while (offset > 0 && wordRegex.test(lastCharacter)) {
            offset--;
            lastCharacter = text.charAt(offset - 1);
        }
        return offset;
    }
    async completionForRule(context, rule, acceptor) {
        if (ast.isParserRule(rule)) {
            const firstFeatures = (0, follow_element_computation_1.findFirstFeatures)(rule.definition);
            await Promise.all(firstFeatures.map(next => this.completionFor(context, next, acceptor)));
        }
    }
    completionFor(context, next, acceptor) {
        if (ast.isKeyword(next.feature)) {
            return this.completionForKeyword(context, next.feature, acceptor);
        }
        else if (ast.isCrossReference(next.feature) && context.node) {
            return this.completionForCrossReference(context, next, acceptor);
        }
    }
    completionForCrossReference(context, crossRef, acceptor) {
        const assignment = (0, ast_util_1.getContainerOfType)(crossRef.feature, ast.isAssignment);
        let node = context.node;
        if (assignment && node) {
            if (crossRef.type && (crossRef.new || node.$type !== crossRef.type)) {
                node = {
                    $type: crossRef.type,
                    $container: node,
                    $containerProperty: crossRef.property
                };
            }
            if (!context) {
                return;
            }
            const refInfo = {
                reference: {},
                container: node,
                property: assignment.feature
            };
            try {
                const scope = this.scopeProvider.getScope(refInfo);
                const duplicateStore = new Set();
                scope.getAllElements().forEach(e => {
                    if (!duplicateStore.has(e.name) && this.filterCrossReference(e)) {
                        acceptor(this.createReferenceCompletionItem(e));
                        duplicateStore.add(e.name);
                    }
                });
            }
            catch (err) {
                console.error(err);
            }
        }
    }
    /**
     * Override this method to change how reference completion items are created.
     * Most notably useful to change the `kind` property which indicates which icon to display on the client.
     *
     * @param nodeDescription The description of a reference candidate
     * @returns A partial completion item
     */
    createReferenceCompletionItem(nodeDescription) {
        return {
            nodeDescription,
            kind: vscode_languageserver_1.CompletionItemKind.Reference,
            detail: nodeDescription.type,
            sortText: '0'
        };
    }
    filterCrossReference(_nodeDescription) {
        return true;
    }
    completionForKeyword(context, keyword, acceptor) {
        // Filter out keywords that do not contain any word character
        if (!keyword.value.match(/[\w]/)) {
            return;
        }
        acceptor({
            label: keyword.value,
            kind: vscode_languageserver_1.CompletionItemKind.Keyword,
            detail: 'Keyword',
            sortText: '1'
        });
    }
    fillCompletionItem(document, offset, item) {
        var _a, _b;
        let label;
        if (typeof item.label === 'string') {
            label = item.label;
        }
        else if ('node' in item) {
            const name = this.nameProvider.getName(item.node);
            if (!name) {
                return undefined;
            }
            label = name;
        }
        else if ('nodeDescription' in item) {
            label = item.nodeDescription.name;
        }
        else {
            return undefined;
        }
        let insertText;
        if (typeof ((_a = item.textEdit) === null || _a === void 0 ? void 0 : _a.newText) === 'string') {
            insertText = item.textEdit.newText;
        }
        else if (typeof item.insertText === 'string') {
            insertText = item.insertText;
        }
        else {
            insertText = label;
        }
        const textEdit = (_b = item.textEdit) !== null && _b !== void 0 ? _b : this.buildCompletionTextEdit(document, offset, label, insertText);
        if (!textEdit) {
            return undefined;
        }
        // Copy all valid properties of `CompletionItem`
        const completionItem = {
            additionalTextEdits: item.additionalTextEdits,
            command: item.command,
            commitCharacters: item.commitCharacters,
            data: item.data,
            detail: item.detail,
            documentation: item.documentation,
            filterText: item.filterText,
            insertText: item.insertText,
            insertTextFormat: item.insertTextFormat,
            insertTextMode: item.insertTextMode,
            kind: item.kind,
            labelDetails: item.labelDetails,
            preselect: item.preselect,
            sortText: item.sortText,
            tags: item.tags,
            textEditText: item.textEditText,
            textEdit,
            label
        };
        return completionItem;
    }
    buildCompletionTextEdit(document, offset, label, newText) {
        const content = document.getText();
        const tokenStart = this.backtrackToTokenStart(content, offset);
        const identifier = content.substring(tokenStart, offset);
        if (this.charactersFuzzyMatch(identifier, label)) {
            const start = document.positionAt(tokenStart);
            const end = document.positionAt(offset);
            return {
                newText,
                range: {
                    start,
                    end
                }
            };
        }
        else {
            return undefined;
        }
    }
    isWordCharacterAt(content, index) {
        return this.grammarConfig.nameRegexp.test(content.charAt(index));
    }
    charactersFuzzyMatch(existingValue, completionValue) {
        if (existingValue.length === 0) {
            return true;
        }
        completionValue = completionValue.toLowerCase();
        let matchedFirstCharacter = false;
        let previous;
        let character = 0;
        const len = completionValue.length;
        for (let i = 0; i < len; i++) {
            const strChar = completionValue.charCodeAt(i);
            const testChar = existingValue.charCodeAt(character);
            if (strChar === testChar || this.toUpperCharCode(strChar) === this.toUpperCharCode(testChar)) {
                matchedFirstCharacter || (matchedFirstCharacter = previous === undefined || // Beginning of word
                    this.isWordTransition(previous, strChar));
                if (matchedFirstCharacter) {
                    character++;
                }
                if (character === existingValue.length) {
                    return true;
                }
            }
            previous = strChar;
        }
        return false;
    }
    isWordTransition(previous, current) {
        return a <= previous && previous <= z && A <= current && current <= Z || // camelCase transition
            previous === _ && current !== _; // snake_case transition
    }
    toUpperCharCode(charCode) {
        if (a <= charCode && charCode <= z) {
            return charCode - 32;
        }
        return charCode;
    }
}
exports.DefaultCompletionProvider = DefaultCompletionProvider;
const a = 'a'.charCodeAt(0);
const z = 'z'.charCodeAt(0);
const A = 'A'.charCodeAt(0);
const Z = 'Z'.charCodeAt(0);
const _ = '_'.charCodeAt(0);
//# sourceMappingURL=completion-provider.js.map