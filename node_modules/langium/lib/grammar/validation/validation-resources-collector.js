"use strict";
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.LangiumGrammarValidationResourcesCollector = void 0;
const collections_1 = require("../../utils/collections");
const stream_1 = require("../../utils/stream");
const ast_1 = require("../generated/ast");
const internal_grammar_util_1 = require("../internal-grammar-util");
const all_types_1 = require("../type-system/type-collector/all-types");
const types_util_1 = require("../type-system/types-util");
const types_1 = require("../type-system/type-collector/types");
const documents_1 = require("../workspace/documents");
class LangiumGrammarValidationResourcesCollector {
    constructor(services) {
        this.documents = services.shared.workspace.LangiumDocuments;
    }
    collectValidationResources(grammar) {
        const typeResources = (0, all_types_1.collectTypeResources)(grammar, this.documents);
        const typeToValidationInfo = this.collectValidationInfo(typeResources);
        const typeToSuperProperties = this.collectSuperProperties(typeResources);
        const typeToAliases = this.collectSubTypesAndAliases(typeToValidationInfo);
        return { typeToValidationInfo, typeToSuperProperties, typeToAliases };
    }
    collectValidationInfo({ astResources, inferred, declared }) {
        const res = new Map();
        const typeNameToRulesActions = collectNameToRulesActions(astResources);
        for (const type of (0, types_util_1.mergeTypesAndInterfaces)(inferred)) {
            res.set(type.name, { inferred: type, inferredNodes: typeNameToRulesActions.get(type.name) });
        }
        const typeNametoInterfacesUnions = (0, stream_1.stream)(astResources.interfaces)
            .concat(astResources.types)
            .reduce((acc, type) => acc.set(type.name, type), new Map());
        for (const type of (0, types_util_1.mergeTypesAndInterfaces)(declared)) {
            const node = typeNametoInterfacesUnions.get(type.name);
            if (node) {
                const inferred = res.get(type.name);
                res.set(type.name, inferred ? Object.assign(Object.assign({}, inferred), { declared: type, declaredNode: node }) : { declared: type, declaredNode: node });
            }
        }
        return res;
    }
    collectSuperProperties({ inferred, declared }) {
        const typeToSuperProperties = new Map();
        for (const type of (0, types_util_1.mergeInterfaces)(inferred, declared)) {
            typeToSuperProperties.set(type.name, Array.from(type.superProperties.values()));
        }
        return typeToSuperProperties;
    }
    collectSubTypesAndAliases(typeToValidationInfo) {
        const nameToType = (0, stream_1.stream)(typeToValidationInfo.entries())
            .reduce((acc, [name, info]) => { acc.set(name, (0, documents_1.isDeclared)(info) ? info.declared : info.inferred); return acc; }, new Map());
        (0, types_util_1.addSubTypes)(nameToType);
        const typeToAliases = new Map();
        function addAlias(name, alias) {
            const aliases = typeToAliases.get(name);
            if (aliases) {
                aliases.add(alias);
            }
            else {
                typeToAliases.set(name, new Set([alias]));
            }
        }
        const queue = Array.from(nameToType.values()).filter(e => e.subTypes.size === 0);
        const visited = new Set();
        for (const type of queue) {
            visited.add(type);
            addAlias(type.name, type.name);
            for (const superTypeName of (0, stream_1.stream)(type.realSuperTypes)) {
                addAlias(superTypeName, type.name);
                const superType = nameToType.get(superTypeName);
                if (superType && !visited.has(superType)) {
                    queue.push(superType);
                }
            }
            if ((0, types_1.isUnionType)(type) && type.alternatives.length === 1) {
                type.alternatives
                    .filter(alt => !alt.array && !alt.reference)
                    .flatMap(alt => alt.types)
                    .forEach(e => {
                    addAlias(type.name, e);
                    addAlias(e, e);
                    addAlias(e, type.name);
                });
            }
        }
        return typeToAliases;
    }
}
exports.LangiumGrammarValidationResourcesCollector = LangiumGrammarValidationResourcesCollector;
function collectNameToRulesActions({ parserRules, datatypeRules }) {
    const acc = new collections_1.MultiMap();
    // collect rules
    (0, stream_1.stream)(parserRules)
        .concat(datatypeRules)
        .forEach(rule => acc.add((0, internal_grammar_util_1.getRuleType)(rule), rule));
    // collect actions
    function collectActions(element) {
        if ((0, ast_1.isAction)(element)) {
            const name = (0, internal_grammar_util_1.getActionType)(element);
            if (name) {
                acc.add(name, element);
            }
        }
        if ((0, ast_1.isAlternatives)(element) || (0, ast_1.isGroup)(element) || (0, ast_1.isUnorderedGroup)(element)) {
            element.elements.forEach(e => collectActions(e));
        }
    }
    parserRules
        .forEach(rule => collectActions(rule.definition));
    return acc;
}
//# sourceMappingURL=validation-resources-collector.js.map