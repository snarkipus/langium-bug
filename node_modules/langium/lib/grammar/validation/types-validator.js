"use strict";
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LangiumGrammarTypesValidator = exports.registerTypeValidationChecks = void 0;
const collections_1 = require("../../utils/collections");
const ast = __importStar(require("../generated/ast"));
const internal_grammar_util_1 = require("../internal-grammar-util");
const types_1 = require("../type-system/type-collector/types");
const types_util_1 = require("../type-system/types-util");
const documents_1 = require("../workspace/documents");
function registerTypeValidationChecks(services) {
    const registry = services.validation.ValidationRegistry;
    const typesValidator = services.validation.LangiumGrammarTypesValidator;
    const checks = {
        Action: [
            typesValidator.checkActionIsNotUnionType,
        ],
        Grammar: [
            typesValidator.checkDeclaredTypesConsistency,
            typesValidator.checkDeclaredAndInferredTypesConsistency,
        ],
    };
    registry.register(checks, typesValidator);
}
exports.registerTypeValidationChecks = registerTypeValidationChecks;
class LangiumGrammarTypesValidator {
    checkDeclaredTypesConsistency(grammar, accept) {
        var _a;
        const validationResources = (_a = grammar.$document) === null || _a === void 0 ? void 0 : _a.validationResources;
        if (validationResources) {
            for (const typeInfo of validationResources.typeToValidationInfo.values()) {
                if ((0, documents_1.isDeclared)(typeInfo) && (0, types_1.isInterfaceType)(typeInfo.declared) && ast.isInterface(typeInfo.declaredNode)) {
                    const declInterface = typeInfo;
                    validateInterfaceSuperTypes(declInterface, validationResources.typeToValidationInfo, accept);
                    validateSuperTypesConsistency(declInterface, validationResources.typeToSuperProperties, accept);
                }
            }
        }
    }
    checkDeclaredAndInferredTypesConsistency(grammar, accept) {
        var _a;
        const validationResources = (_a = grammar.$document) === null || _a === void 0 ? void 0 : _a.validationResources;
        if (validationResources) {
            for (const typeInfo of validationResources.typeToValidationInfo.values()) {
                if ((0, documents_1.isInferred)(typeInfo) && typeInfo.inferred instanceof types_1.InterfaceType) {
                    validateInferredInterface(typeInfo.inferred, accept);
                }
                if ((0, documents_1.isInferredAndDeclared)(typeInfo)) {
                    validateDeclaredAndInferredConsistency(typeInfo, validationResources.typeToAliases, accept);
                }
            }
        }
    }
    checkActionIsNotUnionType(action, accept) {
        if (ast.isType(action.type)) {
            accept('error', 'Actions cannot create union types.', { node: action, property: 'type' });
        }
    }
}
exports.LangiumGrammarTypesValidator = LangiumGrammarTypesValidator;
///////////////////////////////////////////////////////////////////////////////
function validateInferredInterface(inferredInterface, accept) {
    inferredInterface.properties.filter(prop => prop.typeAlternatives.length > 1).forEach(prop => {
        const typeKind = (type) => type.reference ? 'ref' : 'other';
        const firstKind = typeKind(prop.typeAlternatives[0]);
        if (prop.typeAlternatives.slice(1).some(type => typeKind(type) !== firstKind)) {
            const targetNode = prop.astNodes.values().next().value;
            if (targetNode) {
                accept('error', `Mixing a cross-reference with other types is not supported. Consider splitting property "${prop.name}" into two or more different properties.`, { node: targetNode });
            }
        }
    });
}
function validateInterfaceSuperTypes({ declared, declaredNode }, validationInfo, accept) {
    declared.printingSuperTypes.forEach((superTypeName, i) => {
        const superType = validationInfo.get(superTypeName);
        if (superType) {
            if ((0, documents_1.isInferred)(superType) && (0, types_1.isUnionType)(superType.inferred) || (0, documents_1.isDeclared)(superType) && (0, types_1.isUnionType)(superType.declared)) {
                accept('error', 'Interfaces cannot extend union types.', { node: declaredNode, property: 'superTypes', index: i });
            }
            if ((0, documents_1.isInferred)(superType) && !(0, documents_1.isDeclared)(superType)) {
                accept('error', 'Extending an inferred type is discouraged.', { node: declaredNode, property: 'superTypes', index: i });
            }
        }
    });
}
function validateSuperTypesConsistency({ declared, declaredNode }, properties, accept) {
    var _a, _b, _c;
    const nameToProp = declared.properties.reduce((acc, e) => acc.add(e.name, e), new collections_1.MultiMap());
    for (const [name, props] of nameToProp.entriesGroupedByKey()) {
        if (props.length > 1) {
            for (const prop of props) {
                accept('error', `Cannot have two properties with the same name '${name}'.`, {
                    node: Array.from(prop.astNodes)[0],
                    property: 'name'
                });
            }
        }
    }
    const allSuperTypes = declared.printingSuperTypes;
    for (let i = 0; i < allSuperTypes.length; i++) {
        for (let j = i + 1; j < allSuperTypes.length; j++) {
            const outerType = allSuperTypes[i];
            const innerType = allSuperTypes[j];
            const outerProps = (_a = properties.get(outerType)) !== null && _a !== void 0 ? _a : [];
            const innerProps = (_b = properties.get(innerType)) !== null && _b !== void 0 ? _b : [];
            const nonIdentical = getNonIdenticalProps(outerProps, innerProps);
            if (nonIdentical.length > 0) {
                accept('error', `Cannot simultaneously inherit from '${outerType}' and '${innerType}'. Their ${nonIdentical.map(e => "'" + e + "'").join(', ')} properties are not identical.`, {
                    node: declaredNode,
                    property: 'name'
                });
            }
        }
    }
    const allSuperProps = new Set();
    for (const superType of allSuperTypes) {
        const props = (_c = properties.get(superType)) !== null && _c !== void 0 ? _c : [];
        for (const prop of props) {
            allSuperProps.add(prop.name);
        }
    }
    for (const ownProp of declared.properties) {
        if (allSuperProps.has(ownProp.name)) {
            const interfaceNode = declaredNode;
            const propNode = interfaceNode.attributes.find(e => e.name === ownProp.name);
            if (propNode) {
                accept('error', `Cannot redeclare property '${ownProp.name}'. It is already inherited from another interface.`, {
                    node: propNode,
                    property: 'name'
                });
            }
        }
    }
}
function getNonIdenticalProps(a, b) {
    const nonIdentical = [];
    for (const outerProp of a) {
        const innerProp = b.find(e => e.name === outerProp.name);
        if (innerProp && !arePropTypesIdentical(outerProp, innerProp)) {
            nonIdentical.push(outerProp.name);
        }
    }
    return nonIdentical;
}
function arePropTypesIdentical(a, b) {
    if (a.optional !== b.optional || a.typeAlternatives.length !== b.typeAlternatives.length) {
        return false;
    }
    for (const firstTypes of a.typeAlternatives) {
        const found = b.typeAlternatives.some(otherTypes => {
            return otherTypes.array === firstTypes.array
                && otherTypes.reference === firstTypes.reference
                && otherTypes.types.length === firstTypes.types.length
                && otherTypes.types.every(e => firstTypes.types.includes(e));
        });
        if (!found)
            return false;
    }
    return true;
}
function validateDeclaredAndInferredConsistency(typeInfo, typeToAliases, accept) {
    const { inferred, declared, declaredNode, inferredNodes } = typeInfo;
    const typeName = declared.name;
    const applyErrorToRulesAndActions = (msgPostfix) => (errorMsg) => inferredNodes.forEach(node => accept('error', `${errorMsg[-1] === '.' ? errorMsg.slice(0, -1) : errorMsg}${msgPostfix ? ` ${msgPostfix}` : ''}.`, (node === null || node === void 0 ? void 0 : node.inferredType) ?
        { node: node === null || node === void 0 ? void 0 : node.inferredType, property: 'name' } :
        { node, property: ast.isAction(node) ? 'type' : 'name' }));
    const applyErrorToProperties = (nodes, errorMessage) => nodes.forEach(node => accept('error', errorMessage, { node, property: ast.isAssignment(node) || ast.isAction(node) ? 'feature' : 'name' }));
    // currently we don't track which assignments belong to which actions and can't apply this error
    const applyMissingPropErrorToRules = (missingProp) => {
        inferredNodes.forEach(node => {
            if (ast.isParserRule(node)) {
                const assignments = (0, internal_grammar_util_1.extractAssignments)(node.definition);
                if (assignments.find(e => e.feature === missingProp) === undefined) {
                    accept('error', `Property '${missingProp}' is missing in a rule '${node.name}', but is required in type '${typeName}'.`, { node, property: 'parameters' });
                }
            }
        });
    };
    if ((0, types_1.isUnionType)(inferred) && (0, types_1.isUnionType)(declared)) {
        validateAlternativesConsistency(inferred.alternatives, declared.alternatives, typeToAliases, applyErrorToRulesAndActions(`in a rule that returns type '${typeName}'`));
    }
    else if ((0, types_1.isInterfaceType)(inferred) && (0, types_1.isInterfaceType)(declared)) {
        validatePropertiesConsistency(inferred.superProperties, declared.superProperties, typeToAliases, applyErrorToRulesAndActions(`in a rule that returns type '${typeName}'`), applyErrorToProperties, applyMissingPropErrorToRules);
    }
    else {
        const errorMessage = `Inferred and declared versions of type '${typeName}' both have to be interfaces or unions.`;
        applyErrorToRulesAndActions()(errorMessage);
        accept('error', errorMessage, { node: declaredNode, property: 'name' });
    }
}
function validateAlternativesConsistency(inferred, declared, typeToAliases, applyErrorToInferredTypes) {
    const errorsInfo = checkAlternativesConsistencyHelper(inferred, declared, typeToAliases);
    for (const errorInfo of errorsInfo) {
        applyErrorToInferredTypes(`A type '${errorInfo.typeAsString}' ${errorInfo.errorMessage}`);
    }
}
function getAllAliases(expected, typeToAliases) {
    const allAliases = expected.types.map(typeName => { var _a; return Array.from((_a = typeToAliases.get(typeName)) !== null && _a !== void 0 ? _a : new Set([typeName])); });
    let branches = [];
    for (const aliasGroup of allAliases) {
        if (branches.length === 0) {
            branches.push([]);
        }
        if (aliasGroup.length === 1) {
            branches.forEach(branch => branch.push(aliasGroup[0]));
        }
        else {
            const backup_branches = JSON.parse(JSON.stringify(branches));
            branches = [];
            for (const alias of aliasGroup) {
                const alias_branches = JSON.parse(JSON.stringify(backup_branches));
                alias_branches.forEach(alias_branch => alias_branch.push(alias));
                branches.push(...alias_branches);
            }
        }
    }
    return branches.map(branch => (0, types_util_1.distinctAndSorted)(branch).join(' | '));
}
function typeAsStringKeywordsReplacement(found) {
    const propTypeWithStr = found.types.filter(e => !e.startsWith('\''));
    propTypeWithStr.push('string');
    return (0, types_util_1.distinctAndSorted)(propTypeWithStr).join(' | ');
}
function checkAlternativesConsistencyHelper(found, expected, typeToAliases) {
    var _a;
    const arrayReferenceError = (found, expected) => found.array && !expected.array && found.reference && !expected.reference ? 'can\'t be an array and a reference' :
        !found.array && expected.array && !found.reference && expected.reference ? 'has to be an array and a reference' :
            found.array && !expected.array ? 'can\'t be an array' :
                !found.array && expected.array ? 'has to be an array' :
                    found.reference && !expected.reference ? 'can\'t be a reference' :
                        !found.reference && expected.reference ? 'has to be a reference' : '';
    const stringToFound = found.reduce((acc, propType) => acc.set((0, types_util_1.distinctAndSorted)(propType.types).join(' | '), propType), new Map());
    const stringToExpected = expected.reduce((acc, propType) => {
        getAllAliases(propType, typeToAliases).forEach(alias => acc.set(alias, propType));
        return acc;
    }, new Map());
    const errorsInfo = [];
    // detects extra type alternatives & check matched ones on consistency by 'array' and 'reference'
    for (const [typeAsString, foundPropertyType] of stringToFound) {
        const expectedPropertyType = (_a = stringToExpected.get(typeAsString)) !== null && _a !== void 0 ? _a : stringToExpected.get(typeAsStringKeywordsReplacement(foundPropertyType));
        if (!expectedPropertyType) {
            errorsInfo.push({ typeAsString, errorMessage: 'is not expected' });
        }
        else if (expectedPropertyType.array !== foundPropertyType.array || expectedPropertyType.reference !== foundPropertyType.reference) {
            errorsInfo.push({ typeAsString, errorMessage: arrayReferenceError(foundPropertyType, expectedPropertyType) });
        }
    }
    return errorsInfo;
}
function validatePropertiesConsistency(inferred, declared, typeToAliases, applyErrorToType, applyErrorToProperties, applyMissingPropErrorToRules) {
    const areBothNotArrays = (found, expected) => !(found.typeAlternatives.length === 1 && found.typeAlternatives[0].array) &&
        !(expected.typeAlternatives.length === 1 && expected.typeAlternatives[0].array);
    // detects extra properties & validates matched ones on consistency by the 'optional' property
    for (const [name, foundProps] of inferred.entriesGroupedByKey()) {
        const foundProp = foundProps[0];
        const expectedProp = declared.get(name)[0];
        if (expectedProp) {
            const foundTypeAsStr = (0, types_1.propertyTypesToString)(foundProp.typeAlternatives);
            const expectedTypeAsStr = (0, types_1.propertyTypesToString)(expectedProp.typeAlternatives);
            if (foundTypeAsStr !== expectedTypeAsStr) {
                const typeAlternativesErrors = checkAlternativesConsistencyHelper(foundProp.typeAlternatives, expectedProp.typeAlternatives, typeToAliases);
                if (typeAlternativesErrors.length > 0) {
                    const errorMsgPrefix = `The assigned type '${foundTypeAsStr}' is not compatible with the declared property '${name}' of type '${expectedTypeAsStr}'`;
                    const propErrors = typeAlternativesErrors
                        .map(errorInfo => ` '${errorInfo.typeAsString}' ${errorInfo.errorMessage}`)
                        .join('; ');
                    applyErrorToProperties(foundProp.astNodes, `${errorMsgPrefix}: ${propErrors}.`);
                }
            }
            if (!expectedProp.optional && foundProp.optional && areBothNotArrays(foundProp, expectedProp)) {
                applyMissingPropErrorToRules(name);
            }
        }
        else {
            applyErrorToProperties(foundProp.astNodes, `A property '${name}' is not expected.`);
        }
    }
    // detects lack of properties
    for (const [name, expectedProperties] of declared.entriesGroupedByKey()) {
        const foundProperty = inferred.get(name);
        if (foundProperty.length === 0 && !expectedProperties.some(e => e.optional)) {
            applyErrorToType(`A property '${name}' is expected.`);
        }
    }
}
//# sourceMappingURL=types-validator.js.map