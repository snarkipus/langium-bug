"use strict";
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectAllAstResources = exports.collectTypeResources = void 0;
const inferred_types_1 = require("./inferred-types");
const declared_types_1 = require("./declared-types");
const ast_util_1 = require("../../../utils/ast-util");
const collections_1 = require("../../../utils/collections");
const ast_1 = require("../../generated/ast");
const internal_grammar_util_1 = require("../../internal-grammar-util");
const types_util_1 = require("../types-util");
const types_1 = require("./types");
function collectTypeResources(grammars, documents) {
    const astResources = collectAllAstResources(grammars, documents);
    const inferred = (0, inferred_types_1.collectInferredTypes)(astResources.parserRules, astResources.datatypeRules);
    const declared = (0, declared_types_1.collectDeclaredTypes)(astResources.interfaces, astResources.types);
    shareSuperTypesFromUnions(inferred, declared);
    addSuperProperties((0, types_util_1.mergeInterfaces)(inferred, declared));
    return { astResources, inferred, declared };
}
exports.collectTypeResources = collectTypeResources;
function addSuperProperties(allTypes) {
    function addSuperPropertiesInternal(type, visited = new Set()) {
        if (visited.has(type))
            return;
        visited.add(type);
        for (const superTypeName of type.printingSuperTypes) {
            const superType = allTypes.find(e => e.name === superTypeName);
            if (superType && (0, types_1.isInterfaceType)(superType)) {
                addSuperPropertiesInternal(superType);
                superType.superProperties
                    .entriesGroupedByKey()
                    .forEach(propInfo => type.superProperties.addAll(propInfo[0], propInfo[1]));
            }
        }
    }
    for (const type of allTypes) {
        addSuperPropertiesInternal(type);
    }
}
function shareSuperTypesFromUnions(inferred, declared) {
    const childToSuper = new collections_1.MultiMap();
    const allUnions = inferred.unions.concat(declared.unions);
    for (const union of allUnions) {
        if (union.reflection) {
            for (const propType of union.alternatives) {
                propType.types.forEach(type => childToSuper.add(type, union.name));
            }
        }
    }
    function addSuperTypes(types, child, parents) {
        var _a;
        const childType = (_a = types.interfaces.find(e => e.name === child)) !== null && _a !== void 0 ? _a : types.unions.find(e => e.name === child);
        if (childType) {
            parents.forEach(e => childType.realSuperTypes.add(e));
        }
    }
    for (const [child, parents] of childToSuper.entriesGroupedByKey()) {
        addSuperTypes(inferred, child, parents);
        addSuperTypes(declared, child, parents);
    }
}
///////////////////////////////////////////////////////////////////////////////
function collectAllAstResources(grammars, documents, visited = new Set(), astResources = { parserRules: [], datatypeRules: [], interfaces: [], types: [] }) {
    if (!Array.isArray(grammars))
        grammars = [grammars];
    for (const grammar of grammars) {
        const doc = (0, ast_util_1.getDocument)(grammar);
        if (visited.has(doc.uri)) {
            continue;
        }
        visited.add(doc.uri);
        for (const rule of grammar.rules) {
            if ((0, ast_1.isParserRule)(rule) && !rule.fragment) {
                if ((0, internal_grammar_util_1.isDataTypeRule)(rule)) {
                    astResources.datatypeRules.push(rule);
                }
                else {
                    astResources.parserRules.push(rule);
                }
            }
        }
        grammar.interfaces.forEach(e => astResources.interfaces.push(e));
        grammar.types.forEach(e => astResources.types.push(e));
        if (documents) {
            const importedGrammars = grammar.imports.map(e => (0, internal_grammar_util_1.resolveImport)(documents, e));
            collectAllAstResources(importedGrammars, documents, visited, astResources);
        }
    }
    return astResources;
}
exports.collectAllAstResources = collectAllAstResources;
//# sourceMappingURL=all-types.js.map