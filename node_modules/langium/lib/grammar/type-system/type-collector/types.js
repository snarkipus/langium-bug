"use strict";
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.propertyTypesToString = exports.TypeResolutionError = exports.InterfaceType = exports.UnionType = exports.isInterfaceType = exports.isUnionType = void 0;
const generator_node_1 = require("../../../generator/generator-node");
const node_processor_1 = require("../../../generator/node-processor");
const collections_1 = require("../../../utils/collections");
const types_util_1 = require("../types-util");
function isUnionType(type) {
    return type && 'alternatives' in type;
}
exports.isUnionType = isUnionType;
function isInterfaceType(type) {
    return type && 'properties' in type;
}
exports.isInterfaceType = isInterfaceType;
class UnionType {
    constructor(name, alts, options) {
        var _a;
        this.realSuperTypes = new Set();
        this.subTypes = new Set();
        this.containerTypes = new Set();
        this.typeTypes = new Set();
        this.name = name;
        this.alternatives = alts;
        this.reflection = (_a = options === null || options === void 0 ? void 0 : options.reflection) !== null && _a !== void 0 ? _a : false;
    }
    toAstTypesString() {
        const unionNode = new generator_node_1.CompositeGeneratorNode();
        unionNode.append(`export type ${this.name} = ${propertyTypesToString(this.alternatives, 'AstType')};`, generator_node_1.NL);
        if (this.reflection) {
            unionNode.append(generator_node_1.NL);
            pushReflectionInfo(unionNode, this.name);
        }
        return (0, node_processor_1.processGeneratorNode)(unionNode);
    }
    toDeclaredTypesString(reservedWords) {
        const unionNode = new generator_node_1.CompositeGeneratorNode();
        unionNode.append(`type ${escapeReservedWords(this.name, reservedWords)} = ${propertyTypesToString(this.alternatives, 'DeclaredType')};`, generator_node_1.NL);
        return (0, node_processor_1.processGeneratorNode)(unionNode);
    }
}
exports.UnionType = UnionType;
class InterfaceType {
    constructor(name, superTypes, properties) {
        this.realSuperTypes = new Set();
        this.subTypes = new Set();
        this.containerTypes = new Set();
        this.typeTypes = new Set();
        this.printingSuperTypes = [];
        this.superProperties = new collections_1.MultiMap();
        this.name = name;
        this.realSuperTypes = new Set(superTypes);
        this.printingSuperTypes = [...superTypes];
        this.properties = properties;
        properties.forEach(prop => this.superProperties.add(prop.name, prop));
    }
    toAstTypesString() {
        const interfaceNode = new generator_node_1.CompositeGeneratorNode();
        const superTypes = this.printingSuperTypes.length > 0 ? (0, types_util_1.distinctAndSorted)([...this.printingSuperTypes]) : ['AstNode'];
        interfaceNode.append(`export interface ${this.name} extends ${superTypes.join(', ')} {`, generator_node_1.NL);
        interfaceNode.indent(body => {
            if (this.containerTypes.size > 0) {
                body.append(`readonly $container: ${(0, types_util_1.distinctAndSorted)([...this.containerTypes]).join(' | ')};`, generator_node_1.NL);
            }
            if (this.typeTypes.size > 0) {
                body.append(`readonly $type: ${(0, types_util_1.distinctAndSorted)([...this.typeTypes]).map(e => `'${e}'`).join(' | ')};`, generator_node_1.NL);
            }
            pushProperties(body, this.properties, 'AstType');
        });
        interfaceNode.append('}', generator_node_1.NL);
        interfaceNode.append(generator_node_1.NL);
        pushReflectionInfo(interfaceNode, this.name);
        return (0, node_processor_1.processGeneratorNode)(interfaceNode);
    }
    toDeclaredTypesString(reservedWords) {
        const interfaceNode = new generator_node_1.CompositeGeneratorNode();
        const name = escapeReservedWords(this.name, reservedWords);
        const superTypes = Array.from(this.printingSuperTypes).join(', ');
        interfaceNode.append(`interface ${name}${superTypes.length > 0 ? ` extends ${superTypes}` : ''} {`, generator_node_1.NL);
        interfaceNode.indent(body => pushProperties(body, this.properties, 'DeclaredType', reservedWords));
        interfaceNode.append('}', generator_node_1.NL);
        return (0, node_processor_1.processGeneratorNode)(interfaceNode);
    }
}
exports.InterfaceType = InterfaceType;
class TypeResolutionError extends Error {
    constructor(message, target) {
        super(message);
        this.name = 'TypeResolutionError';
        this.target = target;
    }
}
exports.TypeResolutionError = TypeResolutionError;
function propertyTypesToString(alternatives, mode = 'AstType') {
    function propertyTypeToString(propertyType) {
        let res = (0, types_util_1.distinctAndSorted)(propertyType.types).join(' | ');
        res = propertyType.reference ? (mode === 'AstType' ? `Reference<${res}>` : `@${res}`) : res;
        res = propertyType.array ? (mode === 'AstType' ? `Array<${res}>` : `${res}[]`) : res;
        return res;
    }
    return (0, types_util_1.distinctAndSorted)(alternatives.map(propertyTypeToString)).join(' | ');
}
exports.propertyTypesToString = propertyTypesToString;
function pushProperties(node, properties, mode, reserved = new Set()) {
    function propertyToString(property) {
        const name = mode === 'AstType' ? property.name : escapeReservedWords(property.name, reserved);
        const optional = property.optional &&
            !property.typeAlternatives.some(e => e.array) &&
            !property.typeAlternatives.every(e => e.types.length === 1 && e.types[0] === 'boolean');
        const propType = propertyTypesToString(property.typeAlternatives, mode);
        return `${name}${optional ? '?' : ''}: ${propType}`;
    }
    (0, types_util_1.distinctAndSorted)(properties, (a, b) => a.name.localeCompare(b.name))
        .forEach(property => node.append(propertyToString(property), generator_node_1.NL));
}
function pushReflectionInfo(node, name) {
    node.append(`export const ${name} = '${name}';`, generator_node_1.NL);
    node.append(generator_node_1.NL);
    node.append(`export function is${name}(item: unknown): item is ${name} {`, generator_node_1.NL);
    node.indent(body => body.append(`return reflection.isInstance(item, ${name});`, generator_node_1.NL));
    node.append('}', generator_node_1.NL);
}
function escapeReservedWords(name, reserved) {
    return reserved.has(name) ? `^${name}` : name;
}
//# sourceMappingURL=types.js.map