"use strict";
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.addSubTypes = exports.sortInterfacesTopologically = exports.mergeTypesAndInterfaces = exports.mergeInterfaces = exports.comparePropertyType = exports.collectSuperTypes = exports.collectChildrenTypes = exports.distinctAndSorted = exports.collectAllProperties = void 0;
const collections_1 = require("../../utils/collections");
const ast_1 = require("../generated/ast");
/**
 * Collects all properties of all interface types. Includes super type properties.
 * @param interfaces A topologically sorted array of interfaces.
 */
function collectAllProperties(interfaces) {
    const map = new collections_1.MultiMap();
    for (const interfaceType of interfaces) {
        map.addAll(interfaceType.name, interfaceType.properties);
    }
    for (const interfaceType of interfaces) {
        for (const superType of interfaceType.printingSuperTypes) {
            const superTypeProperties = map.get(superType);
            if (superTypeProperties) {
                map.addAll(interfaceType.name, superTypeProperties);
            }
        }
    }
    return map;
}
exports.collectAllProperties = collectAllProperties;
function distinctAndSorted(list, compareFn) {
    return Array.from(new Set(list)).sort(compareFn);
}
exports.distinctAndSorted = distinctAndSorted;
function collectChildrenTypes(interfaceNode, references, langiumDocuments, nodeLocator) {
    const childrenTypes = new Set();
    childrenTypes.add(interfaceNode);
    const refs = references.findReferences(interfaceNode, {});
    refs.forEach(ref => {
        const doc = langiumDocuments.getOrCreateDocument(ref.sourceUri);
        const astNode = nodeLocator.getAstNode(doc.parseResult.value, ref.sourcePath);
        if ((0, ast_1.isInterface)(astNode)) {
            childrenTypes.add(astNode);
            const childrenOfInterface = collectChildrenTypes(astNode, references, langiumDocuments, nodeLocator);
            childrenOfInterface.forEach(child => childrenTypes.add(child));
        }
        else if (astNode && (0, ast_1.isType)(astNode.$container)) {
            childrenTypes.add(astNode.$container);
        }
    });
    return childrenTypes;
}
exports.collectChildrenTypes = collectChildrenTypes;
function collectSuperTypes(ruleNode) {
    const superTypes = new Set();
    if ((0, ast_1.isInterface)(ruleNode)) {
        superTypes.add(ruleNode);
        ruleNode.superTypes.forEach(superType => {
            if ((0, ast_1.isInterface)(superType.ref)) {
                superTypes.add(superType.ref);
                const collectedSuperTypes = collectSuperTypes(superType.ref);
                for (const superType of collectedSuperTypes) {
                    superTypes.add(superType);
                }
            }
        });
    }
    else if ((0, ast_1.isType)(ruleNode)) {
        ruleNode.typeAlternatives.forEach(typeAlternative => {
            var _a;
            if ((_a = typeAlternative.refType) === null || _a === void 0 ? void 0 : _a.ref) {
                if ((0, ast_1.isInterface)(typeAlternative.refType.ref) || (0, ast_1.isType)(typeAlternative.refType.ref)) {
                    const collectedSuperTypes = collectSuperTypes(typeAlternative.refType.ref);
                    for (const superType of collectedSuperTypes) {
                        superTypes.add(superType);
                    }
                }
            }
        });
    }
    return superTypes;
}
exports.collectSuperTypes = collectSuperTypes;
function comparePropertyType(a, b) {
    return a.array === b.array &&
        a.reference === b.reference &&
        compareLists(a.types, b.types);
}
exports.comparePropertyType = comparePropertyType;
function compareLists(a, b, eq = (x, y) => x === y) {
    const distinctAndSortedA = distinctAndSorted(a);
    const distinctAndSortedB = distinctAndSorted(b);
    if (distinctAndSortedA.length !== distinctAndSortedB.length)
        return false;
    return distinctAndSortedB.every((e, i) => eq(e, distinctAndSortedA[i]));
}
function mergeInterfaces(inferred, declared) {
    return inferred.interfaces.concat(declared.interfaces);
}
exports.mergeInterfaces = mergeInterfaces;
function mergeTypesAndInterfaces(astTypes) {
    return astTypes.interfaces.concat(astTypes.unions);
}
exports.mergeTypesAndInterfaces = mergeTypesAndInterfaces;
/**
 * Performs topological sorting on the generated interfaces.
 * @param interfaces The interfaces to sort topologically.
 * @returns A topologically sorted set of interfaces.
 */
function sortInterfacesTopologically(interfaces) {
    const nodes = interfaces
        .sort((a, b) => a.name.localeCompare(b.name))
        .map(e => ({ value: e, nodes: [] }));
    for (const node of nodes) {
        node.nodes = nodes.filter(e => node.value.realSuperTypes.has(e.value.name));
    }
    const l = [];
    const s = nodes.filter(e => e.nodes.length === 0);
    while (s.length > 0) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const n = s.shift();
        if (!l.includes(n)) {
            l.push(n);
            nodes
                .filter(e => e.nodes.includes(n))
                .forEach(m => s.push(m));
        }
    }
    return l.map(e => e.value);
}
exports.sortInterfacesTopologically = sortInterfacesTopologically;
function addSubTypes(nameToType) {
    var _a;
    for (const interfaceType of nameToType.values()) {
        for (const superTypeName of interfaceType.realSuperTypes) {
            (_a = nameToType.get(superTypeName)) === null || _a === void 0 ? void 0 : _a.subTypes.add(interfaceType.name);
        }
    }
}
exports.addSubTypes = addSubTypes;
//# sourceMappingURL=types-util.js.map