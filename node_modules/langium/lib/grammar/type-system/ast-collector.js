"use strict";
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.specifyAstNodeProperties = exports.collectAst = void 0;
const types_util_1 = require("./types-util");
const types_1 = require("./type-collector/types");
const all_types_1 = require("./type-collector/all-types");
const internal_grammar_util_1 = require("../internal-grammar-util");
/**
 * Collects all types for the generated AST. The types collector entry point.
 * @param documents Documents to resolve imports that were used in the given grammars.
 * @param grammars Grammars for which it's necessary to build an AST.
 */
function collectAst(grammars, documents) {
    const { inferred, declared } = (0, all_types_1.collectTypeResources)(grammars, documents);
    const astTypes = {
        interfaces: (0, types_util_1.sortInterfacesTopologically)(mergeAndRemoveDuplicates(inferred.interfaces, declared.interfaces)),
        unions: mergeAndRemoveDuplicates(inferred.unions, declared.unions),
    };
    specifyAstNodeProperties(astTypes);
    return astTypes;
}
exports.collectAst = collectAst;
function mergeAndRemoveDuplicates(inferred, declared) {
    return Array.from(inferred.concat(declared)
        .reduce((acc, type) => { acc.set(type.name, type); return acc; }, new Map())
        .values()).sort((a, b) => a.name.localeCompare(b.name));
}
function specifyAstNodeProperties(astTypes) {
    const nameToType = filterInterfaceLikeTypes(astTypes);
    (0, types_util_1.addSubTypes)(nameToType);
    buildContainerTypes(nameToType);
    buildTypeTypes(nameToType);
}
exports.specifyAstNodeProperties = specifyAstNodeProperties;
function buildTypeTypes(nameToType) {
    const queue = Array.from(nameToType.values()).filter(e => e.subTypes.size === 0);
    const visited = new Set();
    for (const type of queue) {
        visited.add(type);
        type.typeTypes.add(type.name);
        const superTypes = Array.from(type.realSuperTypes)
            .map(superType => nameToType.get(superType))
            .filter(e => e !== undefined);
        for (const superType of superTypes) {
            type.typeTypes.forEach(e => superType.typeTypes.add(e));
        }
        queue.push(...superTypes.filter(e => !visited.has(e)));
    }
}
/**
 * Removes union types that reference only to primitive types or
 * types that reference only to primitive types.
 */
function filterInterfaceLikeTypes({ interfaces, unions }) {
    const nameToType = interfaces.concat(unions)
        .reduce((acc, e) => { acc.set(e.name, e); return acc; }, new Map());
    const cache = new Map();
    function isDataTypeUnion(union, visited = new Set()) {
        if (cache.has(union))
            return cache.get(union);
        if (visited.has(union))
            return true;
        visited.add(union);
        const ruleCalls = union.alternatives.flatMap(e => e.types).filter(e => !(0, internal_grammar_util_1.isPrimitiveType)(e));
        if (ruleCalls.length === 0) {
            return true;
        }
        for (const ruleCall of ruleCalls) {
            const type = nameToType.get(ruleCall);
            if (type && ((0, types_1.isInterfaceType)(type) || (0, types_1.isUnionType)(type) && !isDataTypeUnion(type, visited))) {
                return false;
            }
        }
        return true;
    }
    for (const union of unions) {
        const isDataType = isDataTypeUnion(union);
        cache.set(union, isDataType);
    }
    for (const [union, isDataType] of cache) {
        if (isDataType) {
            nameToType.delete(union.name);
        }
    }
    return nameToType;
}
/**
 * Builds container types for given interfaces.
 * @param interfaces The interfaces that have to get container types.
 */
function buildContainerTypes(nameToType) {
    var _a;
    const types = Array.from(nameToType.values());
    // 1st stage: collect container types
    const interfaces = types.filter(e => (0, types_1.isInterfaceType)(e));
    for (const interfaceType of interfaces) {
        const refTypes = interfaceType.properties.flatMap(property => property.typeAlternatives.filter(e => !e.reference).flatMap(e => e.types));
        for (const refType of refTypes) {
            (_a = nameToType.get(refType)) === null || _a === void 0 ? void 0 : _a.containerTypes.add(interfaceType.name);
        }
    }
    // 2nd stage: share container types
    const connectedComponents = calculateConnectedComponents(types);
    shareContainerTypes(connectedComponents);
}
function calculateConnectedComponents(interfaces) {
    function dfs(typeInterface) {
        const component = [typeInterface];
        visited.add(typeInterface.name);
        const allTypes = [...typeInterface.subTypes, ...typeInterface.realSuperTypes];
        for (const nextTypeInterfaceName of allTypes) {
            if (!visited.has(nextTypeInterfaceName)) {
                const nextTypeInterface = interfaces.find(e => e.name === nextTypeInterfaceName);
                if (nextTypeInterface) {
                    component.push(...dfs(nextTypeInterface));
                }
            }
        }
        return component;
    }
    const connectedComponents = [];
    const visited = new Set();
    for (const typeInterface of interfaces) {
        if (!visited.has(typeInterface.name)) {
            connectedComponents.push(dfs(typeInterface));
        }
    }
    return connectedComponents;
}
function shareContainerTypes(connectedComponents) {
    for (const component of connectedComponents) {
        const superSet = new Set();
        component.forEach(type => type.containerTypes.forEach(e => superSet.add(e)));
        component.forEach(type => type.containerTypes = superSet);
    }
}
//# sourceMappingURL=ast-collector.js.map