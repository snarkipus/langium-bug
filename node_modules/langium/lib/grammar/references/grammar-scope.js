"use strict";
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.LangiumGrammarScopeComputation = exports.LangiumGrammarScopeProvider = void 0;
const scope_computation_1 = require("../../references/scope-computation");
const scope_provider_1 = require("../../references/scope-provider");
const ast_util_1 = require("../../utils/ast-util");
const stream_1 = require("../../utils/stream");
const uri_util_1 = require("../../utils/uri-util");
const ast_1 = require("../generated/ast");
const internal_grammar_util_1 = require("../internal-grammar-util");
class LangiumGrammarScopeProvider extends scope_provider_1.DefaultScopeProvider {
    constructor(services) {
        super(services);
    }
    getScope(context) {
        const referenceType = this.reflection.getReferenceType(context);
        if (referenceType === ast_1.AbstractType) {
            return this.getTypeScope(referenceType, context);
        }
        else {
            return super.getScope(context);
        }
    }
    getTypeScope(referenceType, context) {
        let localScope;
        const precomputed = (0, ast_util_1.getDocument)(context.container).precomputedScopes;
        const rootNode = (0, ast_util_1.findRootNode)(context.container);
        if (precomputed && rootNode) {
            const allDescriptions = precomputed.get(rootNode);
            if (allDescriptions.length > 0) {
                localScope = (0, stream_1.stream)(allDescriptions).filter(des => des.type === ast_1.Interface || des.type === ast_1.Type);
            }
        }
        const globalScope = this.getGlobalScope(referenceType, context);
        if (localScope) {
            return this.createScope(localScope, globalScope);
        }
        else {
            return globalScope;
        }
    }
    getGlobalScope(referenceType, context) {
        const grammar = (0, ast_util_1.getContainerOfType)(context.container, ast_1.isGrammar);
        if (!grammar) {
            return scope_provider_1.EMPTY_SCOPE;
        }
        const importedUris = (0, stream_1.stream)(grammar.imports).map(internal_grammar_util_1.resolveImportUri).nonNullable();
        let importedElements = this.indexManager.allElements(referenceType)
            .filter(des => importedUris.some(importedUri => (0, uri_util_1.equalURI)(des.documentUri, importedUri)));
        if (referenceType === ast_1.AbstractType) {
            importedElements = importedElements.filter(des => des.type === ast_1.Interface || des.type === ast_1.Type);
        }
        return new scope_provider_1.StreamScope(importedElements);
    }
}
exports.LangiumGrammarScopeProvider = LangiumGrammarScopeProvider;
class LangiumGrammarScopeComputation extends scope_computation_1.DefaultScopeComputation {
    constructor(services) {
        super(services);
        this.astNodeLocator = services.workspace.AstNodeLocator;
    }
    exportNode(node, exports, document) {
        var _a;
        super.exportNode(node, exports, document);
        if ((0, ast_1.isParserRule)(node)) {
            if (!node.returnType && !node.dataType) {
                // Export inferred rule type as interface
                const typeNode = (_a = node.inferredType) !== null && _a !== void 0 ? _a : node;
                exports.push({
                    node: typeNode,
                    name: typeNode.name,
                    type: 'Interface',
                    documentUri: document.uri,
                    path: this.astNodeLocator.getAstNodePath(typeNode)
                });
            }
            (0, ast_util_1.streamAllContents)(node).forEach(childNode => {
                if ((0, ast_1.isAction)(childNode) && childNode.inferredType) {
                    const typeName = (0, internal_grammar_util_1.getActionType)(childNode);
                    if (typeName) {
                        // Export inferred action type as interface
                        exports.push({
                            node,
                            name: typeName,
                            type: 'Interface',
                            documentUri: document.uri,
                            path: this.astNodeLocator.getAstNodePath(node)
                        });
                    }
                }
            });
        }
    }
    processNode(node, document, scopes) {
        if ((0, ast_1.isReturnType)(node))
            return;
        this.processTypeNode(node, document, scopes);
        this.processActionNode(node, document, scopes);
        super.processNode(node, document, scopes);
    }
    /**
     * Add synthetic Interface in case of explicitly or implicitly inferred type:<br>
     * cases: `ParserRule: ...;` or `ParserRule infers Type: ...;`
     */
    processTypeNode(node, document, scopes) {
        var _a;
        const container = node.$container;
        if (container && (0, ast_1.isParserRule)(node) && !node.returnType && !node.dataType) {
            const typeNode = (_a = node.inferredType) !== null && _a !== void 0 ? _a : node;
            scopes.add(container, {
                node: typeNode,
                name: typeNode.name,
                type: 'Interface',
                documentUri: document.uri,
                path: this.astNodeLocator.getAstNodePath(typeNode)
            });
        }
    }
    /**
     * Add synthetic Interface in case of explicitly inferred type:
     *
     * case: `{infer Action}`
     */
    processActionNode(node, document, scopes) {
        const container = (0, ast_util_1.findRootNode)(node);
        if (container && (0, ast_1.isAction)(node) && node.inferredType) {
            const typeName = (0, internal_grammar_util_1.getActionType)(node);
            if (typeName) {
                scopes.add(container, {
                    node,
                    name: typeName,
                    type: 'Interface',
                    documentUri: document.uri,
                    path: this.astNodeLocator.getAstNodePath(node)
                });
            }
        }
    }
}
exports.LangiumGrammarScopeComputation = LangiumGrammarScopeComputation;
//# sourceMappingURL=grammar-scope.js.map