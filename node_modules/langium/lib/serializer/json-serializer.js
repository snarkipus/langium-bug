"use strict";
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultJsonSerializer = void 0;
const syntax_tree_1 = require("../syntax-tree");
function isIntermediateReference(obj) {
    return typeof obj === 'object' && !!obj && ('$ref' in obj || '$error' in obj);
}
class DefaultJsonSerializer {
    constructor(services) {
        this.ignoreProperties = new Set(['$container', '$containerProperty', '$containerIndex', '$document', '$cstNode']);
        this.astNodeLocator = services.workspace.AstNodeLocator;
        this.nameProvider = services.references.NameProvider;
    }
    serialize(node, options) {
        return JSON.stringify(node, (key, value) => this.replacer(key, value, options === null || options === void 0 ? void 0 : options.refText), options === null || options === void 0 ? void 0 : options.space);
    }
    deserialize(content) {
        const root = JSON.parse(content);
        this.linkNode(root, root);
        return root;
    }
    replacer(key, value, refText) {
        var _a, _b;
        if (this.ignoreProperties.has(key)) {
            return undefined;
        }
        else if ((0, syntax_tree_1.isReference)(value)) {
            const refValue = value.ref;
            const $refText = refText ? value.$refText : undefined;
            if (refValue) {
                return {
                    $refText,
                    $ref: '#' + (refValue && this.astNodeLocator.getAstNodePath(refValue))
                };
            }
            else {
                return {
                    $refText,
                    $error: (_b = (_a = value.error) === null || _a === void 0 ? void 0 : _a.message) !== null && _b !== void 0 ? _b : 'Could not resolve reference'
                };
            }
        }
        return value;
    }
    linkNode(node, root, container, containerProperty, containerIndex) {
        for (const [propertyName, item] of Object.entries(node)) {
            if (Array.isArray(item)) {
                for (let index = 0; index < item.length; index++) {
                    const element = item[index];
                    if (isIntermediateReference(element)) {
                        item[index] = this.reviveReference(node, propertyName, root, element);
                    }
                    else if ((0, syntax_tree_1.isAstNode)(element)) {
                        this.linkNode(element, root, node, propertyName, index);
                    }
                }
            }
            else if (isIntermediateReference(item)) {
                node[propertyName] = this.reviveReference(node, propertyName, root, item);
            }
            else if ((0, syntax_tree_1.isAstNode)(item)) {
                this.linkNode(item, root, node, propertyName);
            }
        }
        const mutable = node;
        mutable.$container = container;
        mutable.$containerProperty = containerProperty;
        mutable.$containerIndex = containerIndex;
    }
    reviveReference(container, property, root, reference) {
        let refText = reference.$refText;
        if (reference.$ref) {
            const ref = this.getRefNode(root, reference.$ref);
            if (!refText) {
                refText = this.nameProvider.getName(ref);
            }
            return {
                $refText: refText !== null && refText !== void 0 ? refText : '',
                ref
            };
        }
        else if (reference.$error) {
            const ref = {
                $refText: refText !== null && refText !== void 0 ? refText : ''
            };
            ref.error = {
                container,
                property,
                message: reference.$error,
                reference: ref
            };
            return ref;
        }
        else {
            return undefined;
        }
    }
    getRefNode(root, path) {
        return this.astNodeLocator.getAstNode(root, path.substring(1));
    }
}
exports.DefaultJsonSerializer = DefaultJsonSerializer;
//# sourceMappingURL=json-serializer.js.map